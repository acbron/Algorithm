## Basic Data Structure

### 递归：汉诺塔问题

*递归（recursive）*是一种调用自己来完成它的部分工作的算法，并且必须在比原始问题小的问题上调用自己

*汉诺塔问题*首先给出三根柱子和n个圆盘，每个圆盘大小各不相同。所有圆盘一开始均在第一根柱子上，并且按照圆盘从大到小往上叠放，要求把圆盘全部移动到第三根柱子上，并且在移动过程中不允许大的圆盘在小的圆盘之上。

分析：要完成汉诺塔问题，首先要考虑到多出的那根可以暂时存放圆盘的柱子（第二根柱子）。不考虑中间过程，那么移动中必然存在这样的一个状态——第一根柱子上放着最大的圆盘，第二根柱子上放着其余的圆盘（圆盘大小从大到小往上堆叠），第三根柱子为空。这时只需要把第一根上的最大的圆盘移动到第三根柱子，再把第二根柱子上的圆盘全部移动到第三根柱子就达到目的了（不考虑第二根柱子上那一叠圆盘移动到第三根柱子的过程）。再考虑到第二根柱子上堆叠的圆盘要移动到第三根柱子这个过程，恰好是规模更小的汉诺塔问题（n-1个圆盘）

	void hanoi(int n, Pole first, Pole third, Pole temp)
	{
		if (n == 0)
			return;
		hanoi(n-1, first, temp, third); //把n-1个移动到第二根柱子
		move(first, third); //把最低部那个移动到第三根柱子
		hanoi(n-1, temp, third, first); //把第二根柱子上的n-1个圆盘移动到第三根柱子
	}

### 栈的出栈序列

对于n个元素进入按顺序入栈，不同的出栈方案数有：

***total = C(n, 2*n) - C(n-1, 2*n)***

### Huffman树

***带权路径长度 = 叶子结点权值 * 叶子结点的路径长度***

考虑权值分别为9，2，5，7的四个结点生成Huffman树，过程如下：

> 取最小的两棵树——2和5，新建结点7，孩子结点为2和5

> 取最小的两棵树——7和7，新建结点14，孩子结点为7和7

> 取最小的两棵树——9和14，新建结点23，孩子结点为9和14

这样就只剩下一棵树，根结点的值为23，叶子结点为2，5，7，9，分别乘以它们的路径长度有2\*3+5\*3+7\*2+9\*1=44，那么44就是这棵Huffman树的带权路径长度

如果求不带权的路径长度，则结果为3+3+2+1=9

### 磁盘访问

**磁盘结构**

> 一块磁盘由一个或多个**盘片（platter）**组成，这些盘片从上到下排列，与一个**中心主轴（spindle）**相连。盘片以恒定速率连续转动。盘片的每个可用表面都有一个**读／写磁头（read/write head）**，也称为**I/O磁头（I/O head）**
> 
> 磁头在一个盘片的某个位置上可以访问的所有位置就构成了一个**磁道（track）**
> 
> 与主轴具有相同距离的，分布在各个盘片上的所有磁道成为一个**柱面（cylinder）**
> 
> 每个磁道分为多个**扇区（sector）**，两个相邻扇区之间有扇区间间隙（intersector gap），扇区间隙内不存储数据

**磁盘读取数据的过程**

> 1. 移动I／O磁头，把它定位到包含数据的磁道上，这个移动称为**寻道（seek）**
> 2. 磁头等待包含数据的扇区旋转到磁头下面
> 3. 数据的实际传送，一个扇区是一次读出或写入的最小数据量
> 
> > 读取一个扇区的数据后，计算机需要花时间处理这些数据，在计算的时候，磁盘继续转动，当一次读取多个相邻的扇区时，计算机处理完第一个扇区的数据后，可能会发现第二个扇区已经从I／O磁头下过去了，这时需要等待磁盘继续旋转，直到需要的扇区到达
>
> > 有一种方法叫做**交错法（interleaving）**，逻辑上相邻的扇区之间的物理距离称为**交错因子（interleaving factor）**，由于磁盘旋转速度和计算机处理每个扇区的数据的时间都是固定的，可以通过设置交错因子，让计算机处理完第一个扇区的数据后，磁头刚好转到第二个需要读取的扇区中
> 
> > 然而，通常还是把一个文件的所有扇区放在一起，因为寻道时间是最慢的，并且通常读取一个文件的扇区后，很可能要读它的下一个扇区。然而，由于同一文件的所有扇区要尽量放在一起，那么如果磁盘快满的时候，没有足够的连续空间存放一个文件，这时就不得不把文件的扇区拆开存放了，所以磁盘越满，文件可能就越零散

在MS-DOS系统中，多个扇区可以集结成组，成为一个**簇（cluster）**，UNIX系统中则把一个扇区称为一个**块（block）**，是文件分配的最小单位，由操作系统维护相关信息，记录在**索引结点（i-node）**中

很多时候，一个文件无法且好存满某个扇区，这就会导致**内部碎片（internal fragmemtation）**，导致空间浪费

此外，其实每个扇区都包含一个扇区头，用来记录每个扇区的状态信息，这也是为什么一个磁盘格式化后，可用的空间变小了的原因

**磁盘访问代价**

> **磁道-磁道代价**是磁头从一个磁道移到相邻磁道的最短时间
> 
> **平均寻道时间**是寻道到某个特定磁道需要的平均时间
> 
> 磁盘旋转速度，单位rpm——round per minute，通常初始旋转时间取转一圈所需时间的一半


