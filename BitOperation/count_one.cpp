/*
 * 输入一个整型数n, 求出从1~n的二进制表示中，1的个数
 * 如n = 3，则有1，10，11，共4个1
 * 
 * 如果n = 2^3 - 1 = 7，二进制为111，则1的个数为3*(2^(3-1))
 * 实际上若n = 2^k - 1，则1的个数为k*(2^(k-1))
 * 这是因为，2^k - 1的二进制表示都是111...1111（若干个1组成）
 * 考虑n = 2^3 - 1 = 7，即111，不难知道111和000组成一对可组成3个1，
 * 110和001组成一对 可构成3个1，101和010组成3个1，即在7以内的
 * 任一一个数，与其按位取反得到的另一个数恰好可合计有3个1
 * 再考虑对称性，为避免重复计算，得k*(2^(k-1))
 *
 * 如果n != 2^k - 1，比如n = 10111
 * 那么计算就分为3部分
 * （1）考虑最高位，则有7(111) + 1个1，这是因为10000~10111这里包含了8个数，
 * 每个数都该计算一次最高位那个1
 * （2）由于n最高位为第五位，那么最高有效位为第四位的所有数都被包含（即包含1111），
 * 所以有4 * (2^(4-1))
 * （3）除去最高位后，得到一个数111，递归求解。
 *
 * 时间复杂度O(logn)
 */

// 计算n的最高位
int get_left_most(int n)
{
	int result = 0;
	while (n) {
		n >>= 1;
		result++;
	}
	return result;
}

int count_one(int n)
{
	if (n == 0)
		return 0;
	int left_most = get_left_most(n);
	if (n == (1 << left_most) - 1)
		return left_most * (1 << (left_most - 1));
	int next = n - (1 << (left_most - 1));
	return (next + 1) + (left_most - 1) * (1 << (left_most - 2)) + count_one(next);
}
