固定根的算法步骤（假定有V个点，E条边）：
    首先确定答案是否存在，即root能否到达所有点（是否连通）
    1.除了根root以外，对于其他所有点v，找出指向点v的最小边，记为minCost[v]，同时记录其前驱pre[v]，这个步骤需要遍历所有边，复杂度O(E)
    2.如果所构成的图无环，则sum{minCost[v]}即是答案。因为这保证了root可到达所有点，如果root是孤立的，则之前选择的边必然会导致环。因为之前选择了V-1条边，而除root外，有V-1个点，显然不符合“树”的概念。
    3.如果出现了环，则将环缩点，设其为sv，则对于所有不在环中的点v，我们有如下连边操作：
weight[v][sv] = min{ weight[v][vi]-minCost[vi] } vi为sv环中的点：这一步的理解是，如果该新连的边后来被选择了，那么minCost[vi]这条边明显是可以取消的。
weight[sv][v] = min{ weight[vi][v] }：这一步是贪心的做法，即环中所有连向不在环中的v，肯定是取最小的更优。
这个过程中，缩点和连边需要O(VE)的复杂度。
    4.重复1，2直到结束。
    算法总复杂度：O(VE)

最小树形图的不固定根版本：
	建立虚拟节点x，令x连所有的点，权值为所有边权的总和+1，求得最后结果减去该值即可，由于虚拟节点的存在，不会显式地出现孤立点，这时通过判断如果存在多与1个节点的pre为root，则说明无解。如果需要求出根节点，由于之前将x与图中的点连边时，我们按顺序连的话，考虑到可以用边去标识点，对于每一个终点v，如果它的pre为root，则标记这条边who，在求结果时，让who-E即可。

