18.n个数字(0,1,...,n-1)形成一个圆圈,从数字 0 开始,每次从这个圆圈中删除
第m个数字(第一个为当前数字本身,第二个为当前数字的下一个数字)。当一个数字
删除后,从被删除数字的下一个继续删除第 m 个数字。
求出在这个圆圈中剩下的最后一个数字。

著名的约瑟夫环问题
递推公式:F[n] = (F[n-1]+k)%n && f[1] = 0;
简单的证明：
设有n个人，编号0~n-1,数到第k个数出列。则一开始是这样的
0,1,2,3,...,k-1,k,k+1,...,n-1
由于从0开始数，所以出列的是k-1，这时k成为了第0个数，从而重新编号有
k,k+1,...,n-1,0,1,2,...,k-2  ---原编号
0,1,.....,n-k-1,,n-k,n-k+1,n-k+2,...,n-2  ---新编号
从新编号可以看出，其实求的是初始n-1个人，数到k出列的问题。
假如知道n-1个人这个子问题的答案为x，那么n个人的答案也就可以求出了。
对于新编号中0对应的是原编号中的k，所以原编号的答案应该是(x+k)%n

int Joseph(int n,int k)
{
	if(n == 0)
		return -1;
	if(n == 1)
		return 0;
	int pre = 0;
	for(int i=2; i<=n; i++)
	{
		int temp = (pre + k) % i;
		pre = temp;
	}
	return pre;
}
