检索(search)：检索可以抽象得看成这样的一个过程，该过程确定一个具有某特定值的元素
是否是某个集合的成员。
检索算法分为三类：顺序表和线性表方法；根据关键码值直接访问方法（散列法）；树索引方法

1.顺序表：即数组，若元素未排序，检索复杂度O(n)，否则用二分查找O(logn);
2.位向量(bit vector)或位图(bitmap)：即存储一个数组，为每个可能的元素分配一个比特
位位置。如果该元素包含在集合中，对应位置置为1，否则为0

3.散列方法(hashing)
概念：把关键码值映射到表中位置来访问记录的过程
散列函数：把关键码值映射到位置的函数
散列表：存储记录的数组，散列表中的每个位置称为槽(slot)

常见的散列函数：
通常，关键码值范围比散列表中的槽多。
(1)用于数值散列的平方取中法(mid-square method)，将关键码值取平方，在长度2^r的表
中，取出结果的中间r位
(2)用于字符串散列的ELFhash:
int ELFhash(char *key)
{
	unsigned long h = 0;
	while(*key)
	{
		h = (h<<4) + *key++;
		unsigned long g = h & 0xF0000000L;
		if(g) h ^= g>>24;
		h &= ~g;
	}
	return h%M;
}

常见的解决冲突方法
如果对于两个不同的key值k1,k2，它们映射到表中的同一个槽，则称k1和k2在该散列函数
下有冲突(collision)
解决冲突策略(collision resolution policy)分为两类，分别有：
(1)开散列方法(open hashing)，也称为单链方法(separate chaining)
具体做法是，将槽定义为一个链表的表头，如果出现冲突，则将冲突的key插入到对应
槽的链表尾。主要适用于主存中，不适合在磁盘中使用，因为链表的哟个元素可能存储在不
同的磁盘块中，频繁地读取磁盘效率低下。
(2)闭散列方法(closed hashing)，也称为开地址方法(open addressing)
桶式散列：将散列表中的槽分成多个桶(bucket)。比如M个槽，分成B个桶，则每个桶包含
M/B个槽。散列函数需要模B。同时还需要一个溢出桶。将关键码值映射到对于的桶中，当桶
满时，则将该关键码置于溢出桶中。
这种方法适用于基于磁盘的散列表，每次检索时把整个桶从磁盘读出，这样就只需读一次磁
盘。
